'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

exports.wrapContract = wrapContract;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function wrapContract(contract, name, abi, txManager) {
  var nonConstantFns = {};
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(abi), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _ref = _step.value;
      var type = _ref.type,
          constant = _ref.constant,
          _name = _ref.name,
          inputs = _ref.inputs;

      if (type === 'function' && constant === false) {
        // Map all of the contract method names + sigs in cases where the method
        // sig is used as the key due to method overloading, e.g.
        // contract["method(address,uint256)"](foo, bar)
        if (inputs.length > 0) {
          var methodSig = _name + '(' + inputs.map(function (i) {
            return i.type;
          }).join(',') + ')';
          nonConstantFns[methodSig] = true;
        }
        // Currently assume that the default method chosen by Ethers when there
        // are multiple overloaded methods of the same name is non-constant
        nonConstantFns[_name] = true;
      }
    }

    // Why is the first argument an almost-empty object? The functions in
    // ethers.Contract are set up as read-only, non-configurable properties, which
    // means if we try to change their values with Proxy, we get an error.
    //
    // But that only happens if the contract is specified as the first argument to
    // Proxy. So we don't do that. Go on, wag your finger.
    //
    // See https://stackoverflow.com/a/48495509/56817 for more explanation.
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var proxy = new Proxy({
    // this is handy for testing, but probably shouldn't be used for anything
    // else
    wrappedContract: contract
  }, {
    get: function get(target, key) {
      if (key in target) return target[key];
      if (!txManager || !nonConstantFns[key]) return contract[key];

      return function () {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return txManager.sendContractCall(contract, key, args, name);
      };
    },
    set: function set(target, key, value) {
      contract[key] = value;
      return true;
    }
  });

  return proxy;
}