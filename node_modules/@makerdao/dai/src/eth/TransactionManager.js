'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _class, _temp;

var _PublicService2 = require('../core/PublicService');

var _PublicService3 = _interopRequireDefault(_PublicService2);

var _TransactionObject = require('./TransactionObject');

var _TransactionObject2 = _interopRequireDefault(_TransactionObject);

var _ethers = require('ethers');

var _abis = require('../../contracts/abis');

var _utils = require('../utils');

var _lodash = require('lodash');

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eslint-disable-next-line
var log = (0, _debug2.default)('dai:testing:txMgr');

var TransactionManager = function (_PublicService) {
  (0, _inherits3.default)(TransactionManager, _PublicService);

  function TransactionManager() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'transactionManager';
    (0, _classCallCheck3.default)(this, TransactionManager);

    var _this = (0, _possibleConstructorReturn3.default)(this, (TransactionManager.__proto__ || (0, _getPrototypeOf2.default)(TransactionManager)).call(this, name, ['web3', 'log', 'nonce']));

    _this._newTxListeners = [];
    _this._tracker = new Tracker();
    return _this;
  }

  // this method must not be async


  (0, _createClass3.default)(TransactionManager, [{
    key: 'sendContractCall',
    value: function sendContractCall(contract, method, args, name) {
      var _this2 = this;

      if (!args) args = [];
      var options = void 0,
          promise = void 0,
          businessObject = void 0,
          metadata = {
        contract: name,
        method: method.replace(/\(.*\)$/g, ''),
        args: args
      },
          lastArg = args[args.length - 1];

      if ((typeof lastArg === 'undefined' ? 'undefined' : (0, _typeof3.default)(lastArg)) === 'object' && lastArg.constructor === Object) {
        options = lastArg;
        args = args.slice(0, args.length - 1);

        // append additional metadata to the default values.
        if (options.metadata) {
          metadata = (0, _extends3.default)({}, metadata, options.metadata);
          delete options.metadata;
        }

        if ((0, _lodash.has)(options, 'promise')) {
          if (options.promise) promise = options.promise;
          delete options.promise;
        }

        if (options.businessObject) {
          businessObject = options.businessObject;
          delete options.businessObject;
        }
      } else {
        options = {};
      }

      // for promise tracking to work, we must return to the caller the result of
      // _createTransactionObject, because that promise is the one stored for
      // lookup to attach lifecycle hooks.
      return this._createTransactionObject((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
        var txOptions;
        return _regenerator2.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2._buildTransactionOptions(options);

              case 2:
                txOptions = _context.sent;
                return _context.abrupt('return', _this2._execute(contract, method, args, txOptions));

              case 4:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, _this2);
      }))(), {
        businessObject: businessObject,
        metadata: metadata,
        promise: promise
      });
    }

    // this method must not be async

  }, {
    key: 'sendTransaction',
    value: function sendTransaction(data, options) {
      var _this3 = this;

      return this._createTransactionObject((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
        var txOptions;
        return _regenerator2.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this3._buildTransactionOptions(data);

              case 2:
                txOptions = _context2.sent;
                _context2.next = 5;
                return _this3.get('web3').eth.sendTransaction(txOptions);

              case 5:
                _context2.t0 = _context2.sent;
                return _context2.abrupt('return', {
                  hash: _context2.t0
                });

              case 7:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, _this3);
      }))(), options);
    }
  }, {
    key: 'onNewTransaction',
    value: function onNewTransaction(callback) {
      this._newTxListeners.push(callback);
    }
  }, {
    key: 'getTransaction',
    value: function getTransaction(promise, label) {
      return this._tracker.get((0, _utils.uniqueId)(promise), label);
    }
  }, {
    key: 'confirm',
    value: function () {
      var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(promise, count) {
        var txs;
        return _regenerator2.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return promise;

              case 2:
                txs = this._tracker.getAll((0, _utils.uniqueId)(promise));
                return _context3.abrupt('return', _promise2.default.all(txs.map(function (tx) {
                  return tx.confirm(count);
                })));

              case 4:
              case 'end':
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function confirm(_x2, _x3) {
        return _ref3.apply(this, arguments);
      }

      return confirm;
    }()
  }, {
    key: 'isMined',
    value: function isMined(promise) {
      return this._tracker.get((0, _utils.uniqueId)(promise)).isMined();
    }
  }, {
    key: 'listen',
    value: function listen(promise, handlers) {
      this._tracker.listen((0, _utils.uniqueId)(promise), handlers);
    }

    // if options.dsProxyAddress is set, execute this contract method through the
    // proxy contract at that address.

  }, {
    key: '_execute',
    value: function _execute(contract, method, args, options) {
      var _contract$interface$f;

      if (!options.dsProxyAddress) return contract[method].apply(contract, (0, _toConsumableArray3.default)(args).concat([options]));

      var dsProxyAddress = options.dsProxyAddress;
      delete options.dsProxyAddress;

      this.get('log').debug('Calling ' + method + ' vis DSProxy at ' + dsProxyAddress);
      var dsProxyContract = new _ethers.Contract(dsProxyAddress, _abis.dappHub.dsProxy, this.get('web3').ethersProvider().getSigner());

      var data = (_contract$interface$f = contract.interface.functions)[method].apply(_contract$interface$f, (0, _toConsumableArray3.default)(args)).data;
      return dsProxyContract.execute(contract.address, data, options);
    }
  }, {
    key: '_createTransactionObject',
    value: function _createTransactionObject(tx) {
      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          businessObject = _ref4.businessObject,
          metadata = _ref4.metadata,
          promise = _ref4.promise;

      var txo = new _TransactionObject2.default(tx, this.get('web3'), this.get('nonce'), {
        businessObject: businessObject,
        metadata: metadata
      });

      this._newTxListeners.forEach(function (cb) {
        return cb(txo);
      });

      var minePromise = txo.mine();

      // we store the transaction object under the unique id of its own mine
      // promise, so that it can be looked up when calling a contract function
      // directly from a service method, e.g. WethToken.deposit.
      this._tracker.store((0, _utils.uniqueId)(minePromise), txo);

      // if the `promise` object is defined in the options argument, we also store
      // the transaction object under that promise's id, so that it can be looked
      // up when calling a contract function indirectly via two or more nested
      // service method calls, e.g.
      // EthereumCdpService.lockEth -> WethToken.deposit.
      if (promise) this._tracker.store((0, _utils.uniqueId)(promise), txo);

      return minePromise;
    }
  }, {
    key: '_buildTransactionOptions',
    value: function () {
      var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(data) {
        return _regenerator2.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.t0 = _extends3.default;
                _context4.t1 = {};
                _context4.t2 = this.get('web3').transactionSettings();
                _context4.t3 = data;
                _context4.next = 6;
                return this.get('nonce').getNonce();

              case 6:
                _context4.t4 = _context4.sent;
                _context4.t5 = {
                  nonce: _context4.t4
                };
                return _context4.abrupt('return', (0, _context4.t0)(_context4.t1, _context4.t2, _context4.t3, _context4.t5));

              case 9:
              case 'end':
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function _buildTransactionOptions(_x5) {
        return _ref5.apply(this, arguments);
      }

      return _buildTransactionOptions;
    }()
  }]);
  return TransactionManager;
}(_PublicService3.default);

exports.default = TransactionManager;
var Tracker = (_temp = _class = function () {
  function Tracker() {
    (0, _classCallCheck3.default)(this, Tracker);

    this._listeners = {};
    this._transactions = {};
  }

  (0, _createClass3.default)(Tracker, [{
    key: 'store',
    value: function store(key, tx) {
      var _this4 = this;

      this._init(key);
      this._transactions[key].push(tx);

      var _loop = function _loop(event) {
        tx.on(event, function () {
          return _this4._listeners[key][event].forEach(function (cb) {
            return cb(tx);
          });
        });
      };

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(this.constructor.states), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var event = _step.value;

          _loop(event);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'listen',
    value: function listen(key, handlers) {
      var _this5 = this;

      this._init(key);

      var _loop2 = function _loop2(_state) {
        var cb = handlers[_state];
        if (_state === 'confirmed') _state = 'finalized';
        _this5._listeners[key][_state].push(cb);

        // if event has already happened, call handler immediately
        _this5._transactions[key].forEach(function (tx) {
          return tx && tx.inOrPastState(_state) && cb(tx);
        });
        state = _state;
      };

      for (var state in handlers) {
        _loop2(state);
      }
    }
  }, {
    key: 'trigger',
    value: function trigger(key, event) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator3.default)(this._listeners[key][event]), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _cb = _step2.value;

          _cb(this._transactions[key]);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: 'getAll',
    value: function getAll(key) {
      return this._transactions[key];
    }
  }, {
    key: 'get',
    value: function get(key) {
      var txs = this._transactions[key];
      if (!txs || txs.length === 0) {
        throw new Error('No transactions for key ' + key);
      }
      if (txs.length > 1) {
        console.warn('Key ' + key + ' matches ' + txs.length + ' transactions; returning the first.');
      }
      return txs[0];
    }
  }, {
    key: '_init',
    value: function _init(key) {
      if (!this._transactions[key]) this._transactions[key] = [];
      if (!this._listeners[key]) {
        this._listeners[key] = this.constructor.states.reduce(function (acc, state) {
          acc[state] = [];
          return acc;
        }, {});
      }
    }
  }]);
  return Tracker;
}(), _class.states = ['pending', 'mined', 'finalized', 'error'], _temp);