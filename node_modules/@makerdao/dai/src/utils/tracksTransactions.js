'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

exports.default = tracksTransactions;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// This is a decorator definition.
//
// If a function is decorated with `@tracksTransactions`, it should expect its
// last argument to be an object with a key named `promise`. It should pass that
// `promise` argument along as a key in the last argument to any non-constant
// function calls it makes to a smart contract (i.e. an instance returned from
// the getContractByX methods in SmartContractService), or any calls it makes to
// other functions that will eventually call such smart contract functions.
//
// This allows TransactionManager to let users input a promise and receive a
// list of all transactions that were created in the course of executing that
// promise, so that they may attach lifecycle callbacks to those transactions.
//
// @tracksTransactions is only necessary when the function is async. If the
// function returns a contract call, but does not make any async calls before
// that, then the async keyword can be removed, and it just needs to have an
// `options` argument that it passes to its contract call.
function tracksTransactions(target, name, descriptor) {
  var original = descriptor.value;
  descriptor.value = function () {
    var _this = this;

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var lastArg = args[args.length - 1];
    var options = void 0;
    if ((typeof lastArg === 'undefined' ? 'undefined' : (0, _typeof3.default)(lastArg)) === 'object' && lastArg.constructor === Object) {
      args = args.slice(0, args.length - 1);
      options = lastArg;
    } else {
      options = {};
    }

    var promise = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
      var newArgs, inner;
      return _regenerator2.default.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return 0;

            case 2:

              // if there's already a promise, reuse it instead of setting this one--
              // this allows the function we're running to behave differently when
              // it's called directly vs. by another function. e.g. lockWeth
              if (!options.promise) options.promise = promise;

              newArgs = [].concat((0, _toConsumableArray3.default)(args), [options]);
              inner = original.apply(_this, newArgs);
              return _context.abrupt('return', inner);

            case 6:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, _this);
    }))();

    return promise;
  };
  return descriptor;
}